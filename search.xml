<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/09/13/escase/"/>
      <url>2021/09/13/escase/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前段时间写需求写到搜索模块，伴着条件越来越多，各种条件组合的也越来越复杂，后期不好维护，所以改进了一下以前的搜索写法，业余时间写了一个小案例，和大家一起探讨探讨。</p></blockquote><h2 id="完整案例"><a href="#完整案例" class="headerlink" title="完整案例"></a>完整案例</h2><p><a href="https://github.com/zxr615/go-escase">https://github.com/zxr615/go-escase</a></p><ul><li><p>基于 es7.14 开发，使用 <a href="https://github.com/medcl/elasticsearch-analysis-ik">ik_smart </a>分词</p></li><li><p>使用 <a href="https://github.com/olivere/elastic">olivere/elastic</a> go-es扩展</p></li><li><p>使用到 <code>gin</code> 路由</p></li><li><p>批量生成 <a href="https://github.com/brianvoe/gofakeit">测试数据</a></p></li><li><p>批量导入数据到es <a href="https://github.com/zxr615/go-escase/blob/master/cmd/article_reload/reload.go">case</a></p></li><li><p>v1改进前代码&amp;v2 改进后代码</p></li></ul><h2 id="请求结构"><a href="#请求结构" class="headerlink" title="请求结构"></a>请求结构</h2><p>SearchRequest 搜索请求结构</p><pre><code class="go">// SearchRequest 搜索请求结构type SearchRequest struct &#123;    Keyword    string `form:&quot;keyword&quot;`                                // 关键词    CategoryId uint8  `form:&quot;category_id&quot;`                            // 分类    Sort       uint8  `form:&quot;sort&quot; binding:&quot;omitempty,oneof=1 2 3&quot;`   // 排序 1=浏览量；2=收藏；3=点赞；    IsSolve    uint8  `form:&quot;is_solve&quot; binding:&quot;omitempty,oneof=1 2&quot;` // 是否解决    Page       int    `form:&quot;page,default=1&quot;`                         // 页数    PageSize   int    `form:&quot;page_size,default=10&quot;`                   // 每页数量&#125;</code></pre><h2 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h2><p>Search() 文章搜索和 Recommend() 文章推荐的代码几乎一样，只是条件有所不同，重复代码太多，也不好维护。</p><p>例：Search() 处理搜索请求</p><pre><code class="go">func (a ArticleV1) Search(c *gin.Context) &#123;    req := new(model.SearchRequest)    if err := c.ShouldBind(req); err != nil &#123;        c.JSON(400, err.Error())        return    &#125;    // 构建搜索    builder := es.Client.Search().Index(model.ArticleEsAlias)    bq := elastic.NewBoolQuery()    // 标题    if req.Keyword != &quot;&quot; &#123;        builder.Query(bq.Must(elastic.NewMatchQuery(&quot;title&quot;, req.Keyword)))    &#125;    // 分类    if req.CategoryId != 0 &#123;        builder.Query(bq.Filter(elastic.NewTermQuery(&quot;category_id&quot;, req.CategoryId)))    &#125;    // 是否解决    if req.IsSolve != 0 &#123;        builder.Query(bq.Filter(elastic.NewTermQuery(&quot;is_solve&quot;, req.IsSolve)))    &#125;    // 排序    switch req.Sort &#123;    case SortBrowseDesc:        builder.Sort(&quot;brows_num&quot;, false)    case SortUpvoteDesc:        builder.Sort(&quot;upvote_num&quot;, false)    case SortCollectDesc:        builder.Sort(&quot;collect_num&quot;, false)    default:        builder.Sort(&quot;created_at&quot;, false)    &#125;    // 分页    from := (req.Page - 1) * req.PageSize    // 指定查询字段    include := []string&#123;&quot;id&quot;, &quot;category_id&quot;, &quot;title&quot;, &quot;brows_num&quot;, &quot;collect_num&quot;, &quot;upvote_num&quot;, &quot;is_recommend&quot;, &quot;is_solve&quot;, &quot;created_at&quot;&#125;    builder.        FetchSourceContext(            elastic.NewFetchSourceContext(true).Include(include...),        ).        From(from).        Size(req.PageSize)    // 执行查询    do, err := builder.Do(context.Background())    if err != nil &#123;        c.JSON(500, err.Error())        return    &#125;    // 获取匹配到的数量    total := do.TotalHits()    // 序列化数据    list := make([]model.SearchResponse, len(do.Hits.Hits))    for i, raw := range do.Hits.Hits &#123;        tmpArticle := model.SearchResponse&#123;&#125;        if err := json.Unmarshal(raw.Source, &amp;tmpArticle); err != nil &#123;            log.Println(err)        &#125;        list[i] = tmpArticle    &#125;    c.JSON(http.StatusOK, gin.H&#123;        &quot;code&quot;: 200,        &quot;data&quot;: gin.H&#123;            &quot;total&quot;: total,            &quot;list&quot;:  list,        &#125;,    &#125;)    return&#125;</code></pre><p>请求测试一下</p><pre><code class="shell">curl GET &#39;127.0.0.1:8080/article/v1/search?keyword=茴香豆&amp;page=1&amp;page_size=2&amp;sort=1&#39;</code></pre><details>  <summary> 点这里查看返回结果 </summary><pre><code class="json">&#123;    &quot;code&quot;: 200,    &quot;data&quot;: &#123;        &quot;list&quot;: [            &#123;                &quot;id&quot;: 8912,                &quot;category_id&quot;: 238,                &quot;title&quot;: &quot;茴香豆上账；又好笑，&quot;,                &quot;brows_num&quot;: 253,                &quot;collect_num&quot;: 34,                &quot;upvote_num&quot;: 203,                &quot;is_recommend&quot;: 2,                &quot;is_solve&quot;: 1,                &quot;created_at&quot;: &quot;2021-02-01 15:19:36&quot;            &#125;             ...        ],        &quot;total&quot;: 157    &#125;&#125;</code></pre></details><p>Recommend() 处理推荐请求</p><details>   <summary> func (a ArticleV1) Recommend(c *gin.Context) {} </summary><pre><code class="go">// Recommend 文章推荐func (a ArticleV1) Recommend(c *gin.Context) &#123;  // 构建搜索  builder := es.Client.Search().Index(model.ArticleEsAlias)  bq := elastic.NewBoolQuery()  builder.Query(bq.Filter(      // 推荐文章      elastic.NewTermQuery(&quot;category_id&quot;, model.ArticleIsRecommendYes),      // 已解决      elastic.NewTermQuery(&quot;is_solve&quot;, model.ArticleIsSolveYes),  ))  // 浏览量排序  builder.Sort(&quot;brows_num&quot;, false)  do, err := builder.From(0).Size(10).Do(context.Background())  if err != nil &#123;      return  &#125;  // 序列化数据  ...</code></pre></details><h2 id="改进后"><a href="#改进后" class="headerlink" title="改进后"></a>改进后</h2><p>先看结果</p><blockquote><p>把所有查询的条件都拆分开来，像查询数据库一样查询 es，多方便呢，只需要组合需要的条件就可以得到想要的结果</p></blockquote><pre><code class="go">// Search 文章搜索func (a ArticleV2) Search(c *gin.Context) &#123;    req := new(model.SearchRequest)    if err := c.ShouldBind(req); err != nil &#123;        c.JSON(400, err.Error())        return    &#125;  // 像查数据库一样方便的添加条件即可查询    list, total, err := service.NewArticle().        WhereKeyword(req.Keyword).        WhereCategoryId(req.CategoryId).        WhereIsSolve(req.IsSolve).        Sort(req.Sort).        Paginate(req.Page, req.PageSize).        DecodeSearch()    if err != nil &#123;        c.JSON(400, err.Error())        return    &#125;    c.JSON(http.StatusOK, gin.H&#123;        &quot;code&quot;: 200,        &quot;data&quot;: gin.H&#123;            &quot;total&quot;: total,            &quot;list&quot;:  list,        &#125;,    &#125;)    return&#125;// Recommend 文章推荐func (a ArticleV2) Recommend(c *gin.Context) &#123;  // 像查数据库一样方便的添加条件即可查询    list, _, err := service.NewArticle().        WhereCategoryId(model.ArticleIsRecommendYes).        WhereIsSolve(model.ArticleIsSolveYes).        OrderByDesc(&quot;brows_num&quot;).        PageSize(5).        DecodeRecommend()    if err != nil &#123;        c.JSON(400, err.Error())        return    &#125;    c.JSON(http.StatusOK, gin.H&#123;        &quot;code&quot;: 200,        &quot;data&quot;: gin.H&#123;            &quot;total&quot;: len(list),            &quot;list&quot;:  list,        &#125;,    &#125;)    return&#125;</code></pre><h2 id="怎么做到的呢"><a href="#怎么做到的呢" class="headerlink" title="怎么做到的呢"></a>怎么做到的呢</h2><blockquote><p>既然只是条件不同，那用组合的方式，把需要的条件组装起来再执行查询</p></blockquote><p>internal/service/article.go</p><p>本案例中涉及到了 <code>es</code> 的 <code>must</code> <code>filter</code> <code>sort</code> 条件，所以我们要先构建一个 <code>struct</code> 保存要组合的条件</p><pre><code class="go">type article struct &#123;    must   []elastic.Query    filter []elastic.Query    sort   []elastic.Sorter    from   int    size   int&#125;</code></pre><p>构造函数</p><pre><code class="go">func NewArticle() *article &#123;    return &amp;article&#123;        must:   make([]elastic.Query, 0),        filter: make([]elastic.Query, 0),        sort:   make([]elastic.Sorter, 0),        from:   0,        size:   10,    &#125;&#125;</code></pre><p>添加组合的条件的方法</p><blockquote><p>刚开始用过 <code>AddKeyword()</code> <code>WithKeyword</code> 方法名，但都感觉不太好，后来想到 <code>Laravel</code> 中有快捷的查询条件的方法，如<code>whereId(1)</code> 会生成 sql ：<code>xxx where id = 1</code> 所以就仿照了 <code>Laravel </code> 的方式命名了</p></blockquote><pre><code class="go">// WhereKeyword 关键词func (a article) WhereKeyword(keyword string) article &#123;    if keyword != &quot;&quot; &#123;        a.must = append(a.must, elastic.NewMatchQuery(&quot;title&quot;, keyword))    &#125;    return a&#125;// WhereCategoryId 分类func (a article) WhereCategoryId(categoryId uint8) article &#123;    if categoryId != 0 &#123;        a.filter = append(a.filter, elastic.NewTermQuery(&quot;category_id&quot;, categoryId))    &#125;    return a&#125;// WhereIsSolve 是否已解决func (a article) WhereIsSolve(isSolve uint8) article &#123;    if isSolve != 0 &#123;        a.filter = append(a.filter, elastic.NewTermQuery(&quot;is_solve&quot;, isSolve))    &#125;    return a&#125;// Sort 排序func (a article) Sort(sort uint8) article &#123;    switch sort &#123;    case SortBrowseDesc:        return a.OrderByDesc(&quot;brows_num&quot;)    case SortUpvoteDesc:        return a.OrderByDesc(&quot;upvote_num&quot;)    case SortCollectDesc:        return a.OrderByDesc(&quot;collect_num&quot;)    &#125;    return a&#125;// OrderByDesc 通过字段倒序排序func (a article) OrderByDesc(field string) article &#123;    a.sort = append(a.sort, elastic.SortInfo&#123;Field: field, Ascending: false&#125;)    return a&#125;// OrderByAsc 通过字段正序排序func (a article) OrderByAsc(field string) article &#123;    a.sort = append(a.sort, elastic.SortInfo&#123;Field: field, Ascending: true&#125;)    return a&#125;// Paginate 分页// page 当前页码// pageSize 每页数量func (a article) Paginate(page, pageSize int) article &#123;    a.from = (page - 1) * pageSize    a.size = pageSize    return a&#125;</code></pre><p>到这里已经把需要的全部条件已经构建好了，现在条件有了，需要执行最后的搜索了</p><pre><code class="go">// Searcher 执行查询func (a article) Searcher(include ...interface&#123;&#125;) ([]json.RawMessage, int64, error) &#123;    builder := es.Client.Search().Index(model.ArticleEsAlias)    // 查询的字段    includeKeys := make([]string, 0)    if len(include) &gt; 0 &#123;        includeKeys = structer.Keys(include[0])    &#125;    // 构建查询    builder.Query(        // 构建 bool query 条件        elastic.NewBoolQuery().Must(a.must...).Filter(a.filter...),    )    // 执行查询    do, err := builder.        FetchSourceContext(elastic.NewFetchSourceContext(true).Include(includeKeys...)).        From(a.from).        Size(a.size).        SortBy(a.sort...).        Do(context.Background())    if err != nil &#123;        return nil, 0, err    &#125;    total := do.TotalHits()    list := make([]json.RawMessage, len(do.Hits.Hits))    for i, hit := range do.Hits.Hits &#123;        list[i] = hit.Source    &#125;    return list, total, nil&#125;</code></pre><p>到这里就可以使用上面构建好的组合条件的模式针对不同的接口条件组合不同的条件获取结果</p><pre><code class="go">list, _, err := service.NewArticle().        WhereCategoryId(model.ArticleIsRecommendYes).        WhereIsSolve(model.ArticleIsSolveYes).        OrderByDesc(&quot;brows_num&quot;).        PageSize(5).        Searcher()</code></pre><p>但这个时候还有个问题，这里的 <code>list</code> 返回的是一个 <code>[]json.RawMessage</code> 的数组，每一条纪录都是一条<code>json</code>字符串，有时候我们需要对查询出来的数据进行进一步的处理，这个时候就需要把内容序列化成对应的 <code>struct</code> 了，我们可以再写一个<code>DecodeXxxx()</code> 的方法，来针对不同的用途序列化成对应的 <code>struct</code></p><blockquote><p>推荐结果的结构体，这样返回一个 <code>[]model.RecommendResponse</code> 可用的结构体，调用时就不直接调用 <code>Searcher()</code> 调用 <code>DecodeRecommend()</code> 就好了。</p></blockquote><pre><code class="go">func (a article) DecodeRecommend() ([]model.RecommendResponse, int64, error) &#123;    rawList, total, err := a.Searcher(new(model.RecommendResponse))    if err != nil &#123;        return nil, total, err    &#125;    list := make([]model.RecommendResponse, len(rawList))    for i, raw := range rawList &#123;        tmp := model.RecommendResponse&#123;&#125;        if err := json.Unmarshal(raw, &amp;tmp); err != nil &#123;            log.Println(err)            continue        &#125;        list[i] = tmp    &#125;    return list, total, nil&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此已经完成了搜索的简单封装，完整的案例可以去 <a href="https://github.com/zxr615/go-escase">https://github.com/zxr615/go-escase</a> 交流交流</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>brew 安装 php</title>
      <link href="2021/08/25/brew-%E5%AE%89%E8%A3%85-php/"/>
      <url>2021/08/25/brew-%E5%AE%89%E8%A3%85-php/</url>
      
        <content type="html"><![CDATA[<blockquote><p>brew 仓库已经没有7.2以下版本的仓库，如果需要一下版本仓库则需要增加 php 的 tap 仓库</p></blockquote><h2 id="php-tap-仓库"><a href="#php-tap-仓库" class="headerlink" title="php-tap 仓库"></a>php-tap 仓库</h2><p><a href="https://github.com/shivammathur/homebrew-php">https://github.com/shivammathur/homebrew-php</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>启动时报错</p><pre><code class="console">dyld: Library not loaded: /opt/homebrew/opt/tidy-html5/lib/libtidy.5.dylib  Referenced from: /opt/homebrew/Cellar/php@7.1/7.1.34_4/bin/php  Reason: image not found</code></pre><blockquote><p>使用源码重新编译</p></blockquote><pre><code class="console">brew reinstall --build-from-source php@7.1</code></pre></li></ul><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://cloud.tencent.com/developer/article/1662505">https://cloud.tencent.com/developer/article/1662505</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> brew </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《指数基金投资指南》</title>
      <link href="2021/08/09/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97/"/>
      <url>2021/08/09/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="估值指标"><a href="#估值指标" class="headerlink" title="估值指标"></a>估值指标</h2><p><a href="http://www.csindex.com.cn/zh-CN/downloads/index-information">http://www.csindex.com.cn/zh-CN/downloads/index-information</a></p><h3 id="市盈率"><a href="#市盈率" class="headerlink" title="市盈率"></a>市盈率</h3><blockquote><p>市盈率是最常用的一个估值指标</p></blockquote><p>计算：公司市值 / 公司盈利（即PE=P/E，其中P代表公司市值，E代表公司盈利）</p><p>市盈率的分母，也就是公司盈利，可以取不同的值：</p><ul><li><p>静态市盈率</p><ul><li>取用公司上一个年度的净利润</li></ul></li><li><p>滚动市盈率</p><ul><li>最近4个季度财报的净利润</li></ul></li><li><p>动态市盈率</p><ul><li>预估的公司下一年度的净利润</li></ul></li></ul><h4 id="市盈率背后的信息"><a href="#市盈率背后的信息" class="headerlink" title="市盈率背后的信息"></a>市盈率背后的信息</h4><ol><li><p>市盈率反映了我们愿意为获取1元的净利润付出多少代价</p><blockquote><p>例如某个公司的市盈率是10，就代表我们愿意为这个公司的1元盈利付出10元。</p></blockquote></li><li><p>估算市值</p><blockquote><p>一个公司一年赚100亿元净利润，市盈率是10，其市值就是1 000亿元</p></blockquote></li><li><p>市盈率的适用范围</p><blockquote><p>流通性好、盈利稳定的品种、</p></blockquote><ol><li>流通性好</li><li>盈利稳定</li></ol></li><li><p>不适用</p><ol><li>行业盈利并不稳定</li><li>没落行业</li><li>周期行业：证券、钢铁、煤炭、证券、航空、航运等</li></ol></li></ol><h2 id="盈利收益率"><a href="#盈利收益率" class="headerlink" title="盈利收益率"></a>盈利收益率</h2><blockquote><p>假如我们把一家公司全部买下来，这家公司一年的盈利能够带给我们的收益率，就是盈利收益率。</p></blockquote><p>计算：公司盈利除以公司市值，与市盈率相反</p><p>盈利收益率也约等于市盈率的<strong>倒数</strong></p><p>例如市盈率是8，那盈利收益率就是12.5%。</p><h2 id="市净率"><a href="#市净率" class="headerlink" title="市净率"></a>市净率</h2><blockquote><p>市净率指的是每股股价与每股净资产的比率，也就是我们说的账面价值</p></blockquote><ul><li>计算：PB＝P/B（其中P代表公司市值，B代表公司净资产）</li><li>净资产：资产减去负债、年报中披露、净资产这个财务指标比盈利更加稳定，而且大多数公司的净资产都是稳定增加的，可以计算出市净率</li><li>资产价值越稳定，市净率的<strong>有效性越高</strong></li><li><strong>当企业的资产大多是比较容易衡量价值的有形资产，并且是长期保值的资产时，比较适合用市净率来估值</strong></li><li>是从买资产的角度来衡量公司</li></ul><p>影响市净率的因素</p><ol><li><p>企业运作资产的效率：ROE</p><ol><li>越高越好</li><li>净利润除以净资产</li><li>ROE越高的企业，资产运作效率越高，市净率也就越高（查理·芒格认证）</li></ol></li><li><p>资产的价值稳定性</p><ol><li>茅台的”酒”会<strong>随着时间的增加不断增值</strong></li><li>英特尔的 CPU <strong>会随着时间的增加不断贬值</strong></li></ol></li><li><p>资产形势</p><ol><li><p>有形资产：地皮、矿山、厂房、原材料</p><p> 价值容易衡量，如果一个企业主要靠无形资产来经营，像律师事务所、广告服务公司、互联网公司，那市净率就<strong>没有多少参考价值了</strong></p></li><li><p>无形资产：企业品牌、高级技术工程师、企业专利、企业的渠道影响力、行业话语权等</p></li></ol></li><li><p>负债大增或亏损</p></li></ol><h2 id="股息率-分红率"><a href="#股息率-分红率" class="headerlink" title="股息率/分红率"></a>股息率/分红率</h2><blockquote><p>股息率、分红率这两个概念很像，但实际上是不同</p><p>这两个比率，分子一样（现金派息额），但是分母一个是<strong>公司市值</strong>，一个是公司<strong>当年净利润</strong>。</p></blockquote><p><strong>分红率</strong>也叫作派息率、分红比例</p><p>股息率         ＝ 股息/市值</p><p>盈利收益率 ＝ 盈利/市值</p><p>分红率         ＝ 股息/盈利</p><p>股息率＝盈利收益率＊分红率</p><h3 id="股息率"><a href="#股息率" class="headerlink" title="股息率"></a>股息率</h3><blockquote><p> 企业过去一年的<strong>现金派息额</strong>除以公司的<strong>总市值</strong></p></blockquote><h3 id="分红率"><a href="#分红率" class="headerlink" title="分红率"></a>分红率</h3><blockquote><p>企业过去一年的<strong>现金派息额</strong>除以公司的<strong>总净利润</strong></p></blockquote><p>分红率一般是公司<strong>预先就设置好了</strong>，并且连续多年都不会有什么改变。<br>例如工商银行，2016年净利润是2 791亿元，2016年现金分红835亿元，分红率为（835/2791）×100%=30%，即会拿出过去一年的净利润的30%，以现金形式派息。</p><h2 id="估值策略"><a href="#估值策略" class="headerlink" title="估值策略"></a>估值策略</h2><h3 id="盈利收益率法"><a href="#盈利收益率法" class="headerlink" title="盈利收益率法"></a>盈利收益率法</h3><blockquote><p>这源自格雷厄姆的思想。格雷厄姆认为，满足两个条件就算高，一是盈利收益率要大于10%，二是盈利收益率要大幅高于同期无风险利率。截至2017年5月31日，无风险利率可以参考10年期国债收益率，在3.5%左右。无风险利率的两倍就是7%。所以在中国，这两条规则目前可以合二为一，即：当指数基金的盈利收益率大于10%，我们就可以开始定投；如果盈利收益率低于10%，这个指数基金对我们就没有了吸引力，应该停止定投，对已经定投的份额则选择持有。</p></blockquote><p>十年期国债目前利率：3±%</p><p><a href="http://www.icbc.com.cn/ICBC/%E7%BD%91%E4%B8%8A%E5%80%BA%E5%88%B8/%E5%80%BA%E5%88%B8%E4%BA%A4%E6%98%93/detail_jizhang_news.htm?bondid=210009"><strong>2021年记账式附息(九期)国债</strong> <strong>210009</strong></a></p><p>则：无风险利率=6%</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul><li>当盈利收益率大于10%时，分批投资</li><li>盈利收益率小于10%，但大于6.4%时，坚定持有已经买入的基金份额。</li><li>当盈利收益率小于6.4%时，分批卖出基金。</li></ul><h4 id="盈利收益率法的局限和适合的品种"><a href="#盈利收益率法的局限和适合的品种" class="headerlink" title="盈利收益率法的局限和适合的品种"></a>盈利收益率法的局限和适合的品种</h4><ol><li><strong>只适合</strong>于流通性比较好、盈利比较稳定的品种</li><li><strong>不适合</strong>盈利增长速度较快或者盈利波动比较大的指数基金</li><li>适合的基金：上证红利、中证红利、上证50、基本面50、上证50AH优选、央视50、恒生指数和恒生中国企业指数等</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基金 </tag>
            
            <tag> 投资 </tag>
            
            <tag> 股票 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl-Ubuntu安装好后的配置</title>
      <link href="2021/05/24/wsl-Ubuntu%E5%AE%89%E8%A3%85%E5%A5%BD%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>2021/05/24/wsl-Ubuntu%E5%AE%89%E8%A3%85%E5%A5%BD%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="wsl-官方文档"><a href="#wsl-官方文档" class="headerlink" title="wsl 官方文档"></a>wsl 官方文档</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/">https://docs.microsoft.com/zh-cn/windows/wsl/</a></p><h2 id="切换-apt-源"><a href="#切换-apt-源" class="headerlink" title="切换 apt 源"></a>切换 apt 源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><pre><code class="console">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak &amp;&amp; sudo vim /etc/apt/sources.list</code></pre><pre><code class="console">sudo apt update</code></pre><h2 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h2><h3 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h3><pre><code class="shell">ssh-keygen -t rsa -C &quot;zxr615@foxmail.com&quot;</code></pre><blockquote><p>创建 <code>RSA</code> <code>DSA</code> <code>ECDSA</code>  <code>ED25519</code> 到 <code>/etc/ssh/*</code></p></blockquote><pre><code class="shell">ssh-keygen -A</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><pre><code class="shell">sudo vim /etc/ssh/sshd_config</code></pre><pre><code class="shell"># 允许公钥登录PubkeyAuthentication yes# 公钥文件AuthorizedKeysFile .ssh/authorized_keys# 允许密码登录PasswordAuthentication yes</code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>查看公钥</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p>客户端中的「id_rsa.pub」内容追加进服务端的 「authorized_keys」中</p><pre><code class="shell">sudo vim ~/.ssh/authorized_keys</code></pre><p>免密登录</p><pre><code class="shell">SSH fanwei@192.168.0.1</code></pre><h3 id="别名登录-区分多个服务器"><a href="#别名登录-区分多个服务器" class="headerlink" title="别名登录,区分多个服务器"></a>别名登录,区分多个服务器</h3><p>客户端：</p><pre><code class="shell">vim ~/.ssh/config</code></pre><p>写入</p><pre><code>Host ubuntu    HostName fanwei.cn    Port 22    User fanwei    IdentityFile ~/.ssh/id_rsa    Host ubuntu2    HostName fanwei2.cn    Port 22    User fanwei    IdentityFile ~/.ssh/id_rsa</code></pre><p>登录</p><pre><code class="shell">ssh ubuntu</code></pre><pre><code class="shell">ssh ubuntu2</code></pre><h3 id="重启生效"><a href="#重启生效" class="headerlink" title="重启生效"></a>重启生效</h3><pre><code>sudo service ssh restart</code></pre><h2 id="sudo免输入密码"><a href="#sudo免输入密码" class="headerlink" title="sudo免输入密码"></a>sudo免输入密码</h2><pre><code class="shell">visudo</code></pre><p>fanwei 用户执行<code>任何命令</code>都不需要输入密码</p><pre><code class="shell">fanwei ALL=(ALL) NOPASSWD: ALL</code></pre><p>fanwei 用户执行 <code>vim</code>命令时不需要输入密码</p><pre><code class="shell">fanwei ALL=(ALL) NOPASSWD: vim</code></pre><h2 id="service命令"><a href="#service命令" class="headerlink" title="service命令"></a>service命令</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><pre><code class="shell">cd /etc/init.d</code></pre><h2 id="终端代理"><a href="#终端代理" class="headerlink" title="终端代理"></a>终端代理</h2><pre><code class="shell">echo &gt;&gt; ~/.zshrc &quot;export ALL_PROXY=socks5://172.24.208.1:7890&quot;</code></pre><pre><code>source ~/.zshrc</code></pre><h2 id="服务自启"><a href="#服务自启" class="headerlink" title="服务自启"></a>服务自启</h2><h3 id="定义自启服务"><a href="#定义自启服务" class="headerlink" title="定义自启服务"></a>定义自启服务</h3><pre><code class="shell">sudo vim /etc/init.wsl</code></pre><h3 id="写入自启内容"><a href="#写入自启内容" class="headerlink" title="写入自启内容"></a>写入自启内容</h3><pre><code class="bash">#! /bin/sh/etc/init.d/ssh $1/etc/init.d/mysql $1</code></pre><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><pre><code class="shell">sudo chmod +x /etc/init.wsl</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code class="shell">sudo /etc/init.wsl [start|stop|restart]</code></pre><h3 id="Windows-端"><a href="#Windows-端" class="headerlink" title="Windows 端"></a>Windows 端</h3><p><code>Win</code> + <code>R</code> 输入 <code>shell:startup</code> </p><p>新建文件：<code>wslStartUp</code></p><pre><code class="vbscript">Set ws = CreateObject(&quot;Wscript.Shell&quot;)ws.run &quot;wsl -d Ubuntu -u root /etc/init.wsl start&quot;, vbhide</code></pre><blockquote><p>如果遇到启动失败，把 <code>wsl -d Ubuntu -u root /etc/init.wsl start</code> 在命令行中运行即可看到错误</p></blockquote><h2 id="安装-net-tools"><a href="#安装-net-tools" class="headerlink" title="安装 net-tools"></a>安装 net-tools</h2><pre><code class="shell">sudo apt install net-tools</code></pre><pre><code class="shell">ifconfig</code></pre><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><pre><code class="shell">sudo apt install gcc</code></pre><h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="console">sudo apt install git</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>设置名称&amp;邮箱</p><pre><code class="console">git config --global user.name &quot;fanwei&quot;</code></pre><pre><code class="console">git config --global user.email &quot;zxr615@foxmail.com&quot;</code></pre><p>不转义(git status 正常显示中文)</p><pre><code class="shell">git config --global core.quotepath false</code></pre><h3 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h3><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><pre><code class="shell">sudo apt install zsh</code></pre><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><pre><code class="shell">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></pre><pre><code class="console">Do you want to change your default shell to zsh? [Y/n] Y你想把你的默认shell改为zsh吗？[Y/n] Y</code></pre><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>zsh-autosuggestion 自动补全</p><pre><code class="shell">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></pre><p>zsh-syntax-highlighting  命令高亮</p><pre><code class="shell">git clone git://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</code></pre><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><pre><code class="shell">vim ~/.zshrc</code></pre><pre><code class="shell">plugins=(  git  zsh-autosuggestions  # 命令是否正确提示，放在最下面  zsh-syntax-highlighting)</code></pre><h2 id="php-amp-php-fpm-amp-composer"><a href="#php-amp-php-fpm-amp-composer" class="headerlink" title="php&amp;php-fpm&amp;composer"></a>php&amp;php-fpm&amp;composer</h2><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><pre><code class="shell">sudo apt install php</code></pre><p>ext-curl</p><pre><code class="shell">sudo apt install ext-curl</code></pre><p>ext-dom</p><pre><code>sudo apt install php7.4-xml</code></pre><blockquote><p>指定php版本，不指定版本使用默认版本</p></blockquote><h3 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h3><pre><code class="shell">sudo apt install php-fpm</code></pre><h3 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h3><pre><code class="shell">sudo apt install composer</code></pre><p>更改源</p><pre><code class="sehll">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></pre><p>多线程</p><pre><code class="shell">composer global require hirak/prestissimo -vvv</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>service php7.4-fpm start</code></pre><h3 id="启动脚本软链"><a href="#启动脚本软链" class="headerlink" title="启动脚本软链"></a>启动脚本软链</h3><blockquote><p>启动时可用 <code>service php-fpm start</code></p></blockquote><pre><code>sudo ln -s /etc/init.d/php7.4-fpm /etc/init.d/php-fpm</code></pre><h2 id="安装-go"><a href="#安装-go" class="headerlink" title="安装 go"></a>安装 go</h2><p><a href="https://golang.org/doc/install?download=go1.16.4.linux-amd64.tar.gz">https://golang.org/doc/install?download=go1.16.4.linux-amd64.tar.gz</a></p><h2 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://github.com/nodesource/distributions#installation-instructions">https://github.com/nodesource/distributions#installation-instructions</a></p><pre><code class="shell">curl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -</code></pre><pre><code class="shell">sudo apt install -y nodejs</code></pre><pre><code class="shell">node -v</code></pre><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><pre><code class="shell">sudo apt install nginx</code></pre><h2 id="安装-redis"><a href="#安装-redis" class="headerlink" title="安装 redis"></a>安装 redis</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code class="shell">sudo apt install redis</code></pre><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><pre><code class="shell">service redis-server start</code></pre><h2 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h2><pre><code class="console">sudo apt install mysql-server</code></pre><h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><pre><code class="shell">sudo service mysql start</code></pre><pre><code class="shell">sudo service mysql stop</code></pre><pre><code class="shell">sudo service mysql restart</code></pre><h3 id="设置安全向导"><a href="#设置安全向导" class="headerlink" title="设置安全向导"></a>设置安全向导</h3><pre><code class="console">sudo mysql_secure_installation</code></pre><pre><code class="console">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) :N您是否要继续使用提供的密码？（按y | Y表示是，按其他任意键表示否）：NPlease set the password for root here.请在这里为root设置密码。Remove anonymous users? (Press y|Y for Yes, any other key for No) :y删除匿名用户？YDisallow root login remotely? (Press y|Y for Yes, any other key for No) :N不允许远程登录根目录？nRemove test database and access to it? y删除测试数据库和对它的访问？ yReload privilege tables now? y现在重新加载权限表？y</code></pre><h3 id="创建一个mysql用户"><a href="#创建一个mysql用户" class="headerlink" title="创建一个mysql用户"></a>创建一个mysql用户</h3><pre><code class="shell">create user fanwei identified by &#39;123456&#39;;</code></pre><h3 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h3><pre><code class="shell"> SHOW GRANTS FOR fanwei;</code></pre><pre><code class="console">+------------------------------------+| Grants for fanwei@%                |+------------------------------------+| GRANT USAGE ON *.* TO `fanwei`@`%` |+------------------------------------+</code></pre><h3 id="给予root权限"><a href="#给予root权限" class="headerlink" title="给予root权限"></a>给予root权限</h3><pre><code># 分配 所有权限 所有数据库.所有表 给 fanwei用户GRANT ALL ON *.* TO fanwei;</code></pre><h3 id="刷新用户权限"><a href="#刷新用户权限" class="headerlink" title="刷新用户权限"></a>刷新用户权限</h3><pre><code class="shell">FLUSH PRIVILEGES;</code></pre><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><pre><code class="shell">SELECT * FROM `user` WHERE User=&quot;fanwei&quot;\G</code></pre><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="shell">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>监听所有 ip</p><pre><code>bind-address            = 0.0.0.0mysqlx-bind-address     = 0.0.0.0</code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="查询配置信息"><a href="#查询配置信息" class="headerlink" title="查询配置信息"></a>查询配置信息</h4><pre><code class="shell">mysqld --verbose --help | more</code></pre><pre><code>...Default options are read from the following files in the given order:默认选项按照给定的顺序从以下文件中读取/etc/my.cnf /etc/mysql/my.cnf /opt/homebrew/etc/my.cnf ~/.my.cnfThe following groups are read: mysqld server mysqld-8.0The following options may be given as the first argument:...</code></pre><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>常常会遇到密码忘记，或者刚设置好然后登录不上的情况，这个时候就需要免密进入后再进行配置</p><pre><code class="shell">vim ~/.my.cnf</code></pre><p>加入配置，重启</p><pre><code class="she">[mysqld]# 免密登录skip-grant-tables</code></pre><p>重新进入</p><pre><code class="shell">mysql -u root -p</code></pre><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><blockquote><p>[mysqld] 下设置</p></blockquote><h4 id="开启查询日志"><a href="#开启查询日志" class="headerlink" title="开启查询日志"></a>开启查询日志</h4><pre><code class="shell"># 开启查询日志general-log=1# 设置日志位置general-log-file=</code></pre><p>或者命令行中执行</p><pre><code>set GLOBAL general_log=&#39;ON&#39;;</code></pre><p>查询是否开启</p><pre><code class="shell">SHOW VARIABLES LIKE &#39;general%&#39;;</code></pre><pre><code class="console">mysql&gt; SHOW VARIABLES LIKE &#39;general%&#39;;+------------------+----------------------------------------------+| Variable_name    | Value                                        |+------------------+----------------------------------------------+| general_log      | ON                                           || general_log_file | /opt/homebrew/var/mysql/fanweideMac-mini.log |+------------------+----------------------------------------------+2 rows in set (0.00 sec)</code></pre><h3 id="查看安全变量值"><a href="#查看安全变量值" class="headerlink" title="查看安全变量值"></a>查看安全变量值</h3><pre><code class="shell">SHOW VARIABLES LIKE &#39;validate_password%&#39;;</code></pre><pre><code class="console">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;+--------------------------------------+--------+| Variable_name                        | Value  |+--------------------------------------+--------+| validate_password.check_user_name    | ON     || validate_password.dictionary_file    |        || validate_password.length             | 8      || validate_password.mixed_case_count   | 1      || validate_password.number_count       | 1      || validate_password.policy             | MEDIUM || validate_password.special_char_count | 1      |+--------------------------------------+--------+</code></pre><h3 id="密码强度"><a href="#密码强度" class="headerlink" title="密码强度"></a>密码强度</h3><pre><code>SET GLOBAL validate_password.policy=LOW;    # 低SET GLOBAL validate_password.policy=MEDIUM; # 中SET GLOBAL validate_password.policy=STRONG; # 高</code></pre><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><ol><li><p>将旧密码指控</p><pre><code class="shell">use mysql</code></pre><pre><code class="shell">update user set authentication_string = &#39;&#39; where user = &#39;root&#39;;</code></pre><pre><code class="shell">quit</code></pre></li><li><p>去除免密码登陆配置</p><pre><code>skip-grant-tables</code></pre></li><li><p>重启</p></li><li><p>重新登录数据库</p><pre><code class="shell">mysql -u root -p</code></pre></li><li><p>重置</p><pre><code class="shell">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;fw123456&#39;;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> wsl2 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Goland文件模板生成文件</title>
      <link href="2021/05/13/%E4%BD%BF%E7%94%A8Goland%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/"/>
      <url>2021/05/13/%E4%BD%BF%E7%94%A8Goland%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>打开 Goland 设置找到 <code>File and Code Templates</code> 新建模板</p><p>velocity 语法：<a href="http://velocity.apache.org/engine/devel/user-guide.html#string-concatenation">http://velocity.apache.org/engine/devel/user-guide.html#string-concatenation</a></p><pre><code class="template">package $&#123;GO_PACKAGE_NAME&#125;#set($HUMP_NAME = $&#123;StringUtils.removeAndHump($&#123;NAME&#125;, &quot;_&quot;)&#125;) #set($MODEL_NAME = $HUMP_NAME.replace(&quot;Dao&quot;, &quot;&quot;))// ab_cd_dao// $HUMP_NAME = AbCdDao// $MODEL_NAME = AbCdtype $&#123;HUMP_NAME&#125; struct &#123;&#125;func ($&#123;HUMP_NAME&#125;) TableName() string &#123;    return &quot;$&#123;NAME&#125;&quot;&#125;</code></pre><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://stackoverflow.com/questions/33611802/lowercase-first-letter-in-apache-velocity">https://stackoverflow.com/questions/33611802/lowercase-first-letter-in-apache-velocity</a></p><p><a href="https://www.coder.work/article/6393553">https://www.coder.work/article/6393553</a></p><p><a href="https://www.codota.com/code/java/methods/org.apache.velocity.util.StringUtils/removeAndHump">https://www.codota.com/code/java/methods/org.apache.velocity.util.StringUtils/removeAndHump</a></p>]]></content>
      
      
      <categories>
          
          <category> Goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Goland </tag>
            
            <tag> Template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换 brew 源</title>
      <link href="2021/05/06/%E6%9B%B4%E6%8D%A2-brew-%E6%BA%90/"/>
      <url>2021/05/06/%E6%9B%B4%E6%8D%A2-brew-%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>中科大镜像</p></blockquote><p>替换 Homebrew</p><pre><code class="console">git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git</code></pre><p>替换 Homebrew Core</p><pre><code class="console">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</code></pre><p>替换 Homebrew Cask</p><pre><code class="console">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</code></pre><p>zsh</p><pre><code class="bash">echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#39; &gt;&gt; ~/.zshrc</code></pre><pre><code class="shell">source ~/.zshrc</code></pre><p>更新brew</p><pre><code class="console">brew update</code></pre><blockquote><p>error: Not a valid ref: refs/remotes/origin/master</p></blockquote><p>如遇到 error 替换为</p><pre><code class="console">brew update --verbose</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> brew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用软件</title>
      <link href="2021/04/23/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>2021/04/23/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="httptoolkit"><a href="#httptoolkit" class="headerlink" title="httptoolkit"></a>httptoolkit</h2><p><a href="https://httptoolkit.tech/">https://httptoolkit.tech/</a></p><p>一个桌面程序，用来拦截和调试各种应用的 HTTP 通信，包括浏览器、安卓应用、命令行应用、Electron 应用等等。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用策略模式和简单工厂模式重写支付模块(二)-优化$request</title>
      <link href="2021/04/15/%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E9%87%8D%E5%86%99%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97(%E4%BA%8C)-%E4%BC%98%E5%8C%96$request/"/>
      <url>2021/04/15/%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E9%87%8D%E5%86%99%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97(%E4%BA%8C)-%E4%BC%98%E5%8C%96$request/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>上一篇文章 <a href="https://learnku.com/articles/55410">使用策略模式和简单工厂模式重写支付模块</a> 最后提到有 <a href="https://learnku.com/articles/55410#ad6115">两点不足之处</a> 后来思考了下觉得可以用一个实体类，把需要的参数都 <code>set</code> 进实体，用 <code>get</code> 方法获取参数，这样 <code>$request</code> 既可以不向下传递，使用 <code>get</code> 方法获取参数又能很明确。</p><h2 id="建立实体类"><a href="#建立实体类" class="headerlink" title="建立实体类"></a>建立实体类</h2><ol><li><p>根据 <a href="https://learnku.com/articles/55410#07c383">vipStrategy策略</a> 第三步中，提取临时订单中公共的数据添加对应的成员方法，并添加 <code>get</code> 和 <code>set</code> 方法，完成<strong>公共实体类</strong></p><pre><code class="php">namespace App\Http\Services\PayOrder\Strategy;abstract class Entity&#123;    protected $ip;    protected $packageCope;    protected $code;    protected $uid;    protected $type;    public function __construct(Request $request)    &#123;        $this-&gt;ip          = $request-&gt;getClientIp();        $this-&gt;code        = $request-&gt;get(&#39;code&#39;);        $this-&gt;uid         = Auth::id();        $this-&gt;packageCope = app(PayOrderService::class)-&gt;getVipByCode($this-&gt;code);        // 为成员方法 `set` 值        foreach ($request-&gt;all() as $fields =&gt; $value) &#123;            $property = &#39;set&#39; . Str::studly($fields);            if (property_exists($this, $fields)) &#123;                $this-&gt;$property = $value;            &#125;        &#125;    &#125;    public function getIp() &#123; return $this-&gt;ip;&#125;    public function setIp($ip) &#123; $this-&gt;ip = $ip;&#125;    public function getCode() &#123; return $this-&gt;code;&#125;    public function setCode($code) &#123; $this-&gt;code = $code;&#125;    public function getUid() &#123; return $this-&gt;uid;&#125;    public function setUid($uid) &#123; $this-&gt;uid = $uid;&#125;    public function getType() &#123; return $this-&gt;type;&#125;    public function setType($type) &#123; $this-&gt;type = $type;&#125;    public function getPackageCope() &#123; return $this-&gt;packageCope;&#125;    public function setPackageCope($packageCope) &#123;$this-&gt;packageCope = $packageCope;&#125;&#125;</code></pre></li><li><p>开通vip实体类</p><pre><code class="php">namespace App\Http\Services\PayOrder\Entity;class VipEntity extends Entity&#123;    // 开通vip月数    protected $buyMonth;    public function getBuyMonth() &#123; return $this-&gt;buyMonth;&#125;    public function setBuyMonth($buyMonth)&#123; $this-&gt;buyMonth = $buyMonth;&#125;&#125;</code></pre></li></ol><h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>vip 接口</p><pre><code class="php">public function vip(Request $request)&#123;    $strategy = new VipStrategy();        // 原代码将$request向下传传递    $tmpOrderKey = (new PayOrderContext($strategy))-&gt;createOrder($request);      // 修改后：通过VipEntity() 构造实体      $vipEntity   = new VipEntity($request);    $tmpOrderKey = (new PayOrderContext($strategy))-&gt;createOrder($vipEntity);    return $this-&gt;data([&#39;key&#39; =&gt; $tmpOrderKey]);&#125;</code></pre><p>VipStrategy.php</p><p>原来：接收vip接口传入的 <code>$request</code>  </p><pre><code class="php">function createTemporaryOrder(Request $request)&#123;    $packageCode = $request[&#39;code&#39;];      $buyMonth    = $request[&#39;buy_month&#39;];    $package     = app(PayOrderService::class)-&gt;getVipByCode($packageCode);    // 临时订单数据    $tmpOrder = [        &#39;package_cope&#39; =&gt; $package-&gt;toArray(),        &#39;type&#39;         =&gt; PayOrderService::TYPE_VIP,        &#39;uid&#39;          =&gt; 1,        &#39;ip&#39;           =&gt; $request-&gt;ip(),          &#39;buy_month&#39;    =&gt; $buyMonth        // ....    ];&#125;</code></pre><p>修改后：接收实体类，通过 <code>$entity</code> 可明确知道有什么参数</p><pre><code class="php">function createTemporaryOrder(Entity $entity)&#123;    // 临时订单数据    $tmpOrder = [        &#39;package_cope&#39; =&gt; $entity-&gt;getPackageCope(),        &#39;type&#39;         =&gt; PayOrderService::TYPE_VIP,        &#39;uid&#39;          =&gt; $entity-&gt;getUid(),        &#39;ip&#39;           =&gt; $entity-&gt;getIp(),        &#39;buy_month&#39;    =&gt; $entity-&gt;getBuyMonth()        // ....    ];    $tmpOrderKey = app(PayOrderService::class)-&gt;saveTemporaryOrder($tmpOrder);    return $tmpOrderKey;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>建立 <code>VipEntity</code> 实体类之后就可以明确参数，并且将 <code>$request</code> 留在控制器中不再向下传递。</li><li>第二个问题不明确 <code>redis</code> 临时订单中有什么数据也可以建立一个实体类，然后想参数 <code>set</code> 完成后就可以愉快的 <code>get</code> 了。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> Alipay </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写一个简单的IoC容器案例，理解什么是依赖注入和控制反转</title>
      <link href="2021/04/07/%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84IoC%E5%AE%B9%E5%99%A8%EF%BC%8C%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
      <url>2021/04/07/%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84IoC%E5%AE%B9%E5%99%A8%EF%BC%8C%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>依赖注入(DI)，控制反转(IoC)，容器(Container) 经常都经常会提到，但很长一段时间都是一知半解，现在抽空把自己浅显理解的内容记录下来，与大家探讨。</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>不知道大家开发时有没有好奇过以下这两个问题呢？</p><ol><li>为什么方法的参数位置①是需要传入 <strong>2</strong> 个参数的，一个是 <code>Request</code> 类型的参数，一个是不定类型的 <code>$id</code> 参数，但路由只有一个 <code>$id</code> 参数，那 <code>$request</code> 参数是哪里来的？</li><li><code>UserService</code> 的 <code>__construct</code> 方法明确实例化需要一个 <code>Cache</code> 类型的参数，但②中并没有传入，为什么能使用呢？③为什么使用 <code>new</code> 不传参数就会报错呢？</li></ol><pre><code class="php">Route::get(&#39;/&#123;id&#125;&#39;,&#39;\App\Http\Controllers\IndexController@index&#39;);</code></pre><pre><code class="php">class IndexController extends Controller&#123;    public function index(Request $request, $id)①    &#123;        app(UserService::class)②-&gt;getUserNameById($id);              ③// TypeError: Too few arguments to function App/Services/UserService::__construct(), 0 passed in Psy Shell code on line 1 and exactly 1 expected        (new UserService())-&gt;getUserNameById($id);    &#125;&#125;</code></pre><pre><code class="php">class UserService&#123;    public $cache;    public function __construct(Cache $cache)    &#123;        $this-&gt;cache = $cache;    &#125;    public function getUserNameById($id)    &#123;        return $this-&gt;cache-&gt;get(&#39;user:id:&#39; . $id);    &#125;&#125;</code></pre><p>原来这叫 <code>依赖注入</code> ，开始也不知道是个啥，那就抱着这两个疑问开始寻找答案。 </p><p>很早之前就很好奇：</p><ol><li>为什么方法的参数位置①是需要传入 <strong>2</strong> 个参数的，一个是 <code>Request</code> 类型的参数，一个是不定类型的 <code>id</code> 参数，但路由只有一个 <code>id</code> 参数，那 <code>$request</code> 参数是哪里来的？</li><li><code>UserService</code> 的 <code>__construct</code> 方法明确实例化需要一个 <code>Cache</code> 类型的参数，但②中并没有传入，为什么能使用呢？③为什么使用 <code>new</code> 如果不传参数就会报错呢？</li></ol><p>不知道大家开发时有没有好奇过这两个问题呢？后来听说这叫 <code>依赖注入</code> ，也不知道是个啥，那就抱着这两个疑问开始寻找答案。 </p><h2 id="贯穿全文"><a href="#贯穿全文" class="headerlink" title="贯穿全文"></a>贯穿全文</h2><p>接下来会围绕这 3 个点来讲</p><ol><li><p>依赖控制</p><ol><li>依赖：谁依赖谁</li><li>注入：注入什么</li></ol></li><li><p>控制反转</p><ol><li>控制：谁控制谁</li><li>反转：反转什么</li></ol></li><li><p>什么是容器</p></li></ol><h2 id="常规代码"><a href="#常规代码" class="headerlink" title="常规代码"></a>常规代码</h2><p>Controller1</p><pre><code class="php">class Index1Controller&#123;    public $userService;    public function __construct() &#123;        /**         * 因为我需要(依赖) UserService() 给我提供数据, 所以创建了一个 UserService() 对象         *         * 控制：我 (IndexController) 控制了 UserService() 对象的创建         * 反转：我 (IndexController) 绝对控制 UserService() 对象的权利，创建对象的控制权没有发生转移，所以没有反转，一切都是亲力亲为。         */        $this-&gt;userService = new UserService();    &#125;    public function index() &#123;        // 我 (index) 控制了 UserService() 对象的创建        $userService = new UserService();        $userName = $userService-&gt;getUserName();        $userName2 = $this-&gt;userService-&gt;getUserName();        return [$userName, $userName2];    &#125;&#125;(new IndexController())-&gt;index();</code></pre><p>Index2.php</p><pre><code class="php">&lt;?php    (new Index1Controller())-&gt;index();</code></pre><p>生活比喻：</p><pre><code>依赖：我要吃面包，面包需要(依赖)面粉才能制作注入：买面粉 -&gt; 注入水 -&gt; 制作面包 -&gt; 吃控制：我控制了面包的制作反转：无</code></pre><h2 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h2><p>Controller2</p><pre><code class="php">class Index2Controller&#123;    public $userService;    /**     * 因为我需要(依赖) UserService() 给我提供数据, 所以我需要接收一个 UserService 类型的参数     * 把依赖从外部传入进来，把需要的依赖传入进来了，就是依赖注入     *     * 控制：调用者控制了 UserService() 对象的创建     * 反转：我 (IndexController) 控制 UserService 创建的权利已经没有了(转移了)，那转移给谁了？这里的控制权转移给调用者了。     */    public function __construct(UserService $userService)    &#123;        $this-&gt;userService = $userService;    &#125;    public function index()    &#123;       /**         * 在方法中创建对象         * 我 (index) 控制了 UserService() 对象的创建         */        $userService = new UserService();        $userName  = $userService-&gt;getUserName();              $userName2 = $this-&gt;userService-&gt;getUserName();        return [$userName, $userName2];    &#125;&#125;// __construct() 中创建 new UserService() 转移到了这里$userService = new UserService();// 将 $userService 传入(注入) controller 中(new Index2Controller($userService))-&gt;index();</code></pre><p>Index2.php</p><pre><code class="php">&lt;?php// __construct() 中创建 new UserService() 转移到了这里$userService = new UserService();// 将 $userService 传入(注入) controller 的构造函数中$rs = (new Index2Controller($userService))-&gt;index();var_dump($rs);</code></pre><p>生活比喻：</p><pre><code class="php">依赖：我要吃面包，依赖面包店注入：告诉面包店老板要吃什么 -&gt; 老板给你(注入) -&gt; 吃控制：面包店老板控制面包的制作反转：原来我控制面包的制作的权利没有了，转移给了面包店的老板</code></pre><h2 id="IoC-容器自动注入"><a href="#IoC-容器自动注入" class="headerlink" title="IoC 容器自动注入"></a>IoC 容器自动注入</h2><p>上面的 <code>依赖注入和控制反转</code> 并没有解决开头引出的两个问题的答案，依赖还是需要手动创建，然后手动注入，如何实现依赖的自动注入呢？这个时候就需要一个 IoC 容器了</p><ul><li><p>如何注入</p><p>  使用 <code>PHP</code> 提供的 <a href="https://www.php.net/manual/en/book.reflection.php">反射(Reflection)</a> 功能</p></li><li><p>我们需要注入哪里的参数</p><p>  依赖注入是以构造函数参数的形式传入，所以我们需要自动注入构造函数指定的参数</p></li><li><p>我们需要注入哪些参数</p><p>  我们只注入类实例，其他参数原样传入</p></li></ul><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>IoC 容器其实就是一个普通的 <code>class</code> 类，实现了某些功能而已，不必想的太复杂。</p><pre><code class="php">class Container&#123;      // 在 laravel 中这个方法是 `make()`, 这里为了方便和常用的 new xxx() 理解，所以命名成了「自动注入的new」    public static function autoInjectNew($className, $params = [])    &#123;        $reflect = new \ReflectionClass($className);        // 获取构造函数        $construct = $reflect-&gt;getConstructor();        // 保存实例化需要的参数        $args = [];        if ($construct) &#123;            /**             * 获取构造函数的参数             * array(2) &#123;             *  [0] =&gt; object(ReflectionParameter)#3 (1) &#123;[&quot;name&quot;]=&gt; string(11) &quot;userService&quot;&#125;             *  [1] =&gt; object(ReflectionParameter)#4 (1) &#123;[&quot;name&quot;]=&gt; string(3) &quot;uid&quot;&#125;             *  &#125;             */            $consParams = $construct-&gt;getParameters();            foreach ($consParams as $param) &#123;                $class = $param-&gt;getClass();                if ($class) &#123;                    // $args[] = new $class-&gt;name();                    // 如果这样处理依赖的的 UserService() 还有依赖的话则无法兼顾，所以需要递归处理                    // demo 中这里相当于就是 new Study\Di\Services\UserService()                    $args[] = self::autoInjectNew($class-&gt;name);                &#125;            &#125;        &#125;        // 合并参数        $args = array_merge($args, $params);        /**         * IoC 控制反转:         *  控制：容器控制了对象的创建         *  反转：创建对象的权利已经转移到了容器中来了，不再是 IndexController() 中的 __construct() 了。         * DI 依赖注入:         *  依赖：$args 保存了保存了需要那些依赖         *  注入：把 $args 中的依赖作为参数传入(注入)，返回实例         */        // 相当于：$instance = new Index3Controller(new UserService)        $instance = $reflect-&gt;newInstanceArgs($args);        return $instance;    &#125;&#125;</code></pre><p>验证一下</p><p>Controller3</p><pre><code class="php">class Index3Controller&#123;    protected $userService;    public function __construct(UserService $userService)    &#123;        $this-&gt;userService = $userService;    &#125;    public function index()    &#123;        $userName = $this-&gt;userService-&gt;getUserName();        return $userName;    &#125;&#125;</code></pre><p>index3.php</p><pre><code class="php">&lt;?php$index3Instance = Container::autoInjectNew(Index3Controller::class);$rs = $index3Instance-&gt;index();var_dump($rs);</code></pre><p>现在再看看是不是没有主动传入 <code>new UserService()</code> 参数也可以成功调用啦</p><h2 id="回顾问题"><a href="#回顾问题" class="headerlink" title="回顾问题"></a>回顾问题</h2><ol><li><p>路由中的 <code>Request $request</code> 参数是哪里来的</p><p> 答：请求进入框架之后，框架解析 <code>url</code> 找到相对应的控制器类，调用容器写好的自动注入方法(案例中是<code>autoInjectNew()</code>)，进行注入参数，这样就可以愉快又方便的使用啦。</p></li><li><p>使用 <code>app()</code> 和 <code>new</code> 有什么不同</p><p> 答：其实 <code>laravel</code> 中 <code>app()</code> 就是使用 <code>Container</code> 实例化的一个助手函数，我们可以来写一个助手函数</p><p> 先看看 <code>laravel</code> 中的助手函数</p><pre><code class="php">function app($abstract = null, array $parameters = [])&#123;    if (is_null($abstract)) &#123;        return Container::getInstance();    &#125;      // 这里的 make 就相当于当前项目中的 autoInjectNew()    return Container::getInstance()-&gt;make($abstract, $parameters);&#125;</code></pre><p> 实现助手函数 app()</p><p> index3.php</p><pre><code class="php">&lt;?php$index3Instance = Container::autoInjectNew(Index3Controller::class);$rs = $index3Instance-&gt;index();var_dump(&quot;indexRs: &quot;, $rs);// 使用助手函数$appRs = app(Index3Controller::class)-&gt;index();var_dump(&quot;appRs: &quot;, $appRs);// 助手函数function app($class, $params = []) &#123;    return Container::autoInjectNew($class, $params);&#125;</code></pre></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刚开始的时候在网上找了很多相关的文章，但看下来说的似乎都大同小异，但还是不理解，很是苦恼。经常看到「服务容器是 Laravel 的核心」这样的说法，所以就去从 <code>laravel</code> 的 <code>index.php</code> 开始一步一步过，但 <code>laravel</code> 的源码看的确实也有点头大，所以我转了个弯，把 <code>ThinkPHP</code> 的的框架 <code>clone</code> 下来看了看，确实看的轻松许多，再回头看 <code>laravel</code> 的源码，还是很复杂，但理解起来相对直接看 <code>laravel</code> 就简单多了。</p><p>文章很多都是作者自己的理解，文章提供的大多也只是很少一部分的代码，要弄清楚还是得阅读源码。</p><p>这个案例的 <code>Container</code> 中似乎没有太体现出 <code>容器</code> 这个词，因为还没有实现实例化对象的存储，具体可以看看相关的源码。</p><h2 id="案例demo"><a href="#案例demo" class="headerlink" title="案例demo"></a>案例demo</h2><p><a href="https://github.com/zxr615/study-ioc">https://github.com/zxr615/study-ioc</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/top-think/framework/blob/6.0/src/think/Container.php">https://github.com/top-think/framework/blob/6.0/src/think/Container.php</a></p><p><a href="https://github.com/laravel/framework/blob/8.x/src/Illuminate/Container/Container.php">https://github.com/laravel/framework/blob/8.x/src/Illuminate/Container/Container.php</a></p><p><a href="https://segmentfault.com/a/1190000018948909">https://segmentfault.com/a/1190000018948909</a></p><p><a href="https://blog.csdn.net/bestone0213/article/details/47424255">https://blog.csdn.net/bestone0213/article/details/47424255</a></p><p><a href="https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html">https://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> IoC </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xdebug &amp; phpstorm 调试</title>
      <link href="2021/04/06/xdebug&amp;phpstorm%E8%B0%83%E8%AF%95/"/>
      <url>2021/04/06/xdebug&amp;phpstorm%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://xdebug.org/docs/install">https://xdebug.org/docs/install</a></p><h2 id="添加xdebug扩展"><a href="#添加xdebug扩展" class="headerlink" title="添加xdebug扩展"></a>添加xdebug扩展</h2><p>php.ini</p><pre><code class="console">; xdebugzend_extension=&quot;xdebug.so&quot;xdebug.mode=&quot;debug&quot;xdebug.client_host=&quot;127.0.0.1&quot;xdebug.client_port=9100</code></pre><h2 id="设置phpstorm"><a href="#设置phpstorm" class="headerlink" title="设置phpstorm"></a>设置phpstorm</h2><img src="https://cdn.jsdelivr.net/gh/zxr615/md-images/images/2020image-20210406112119754.png" alt="image-20210406112119754" style="zoom: 25%" /><img src="https://cdn.jsdelivr.net/gh/zxr615/md-images/images/2020image-20210406112400893.png" alt="image-20210406112400893" style="zoom: 25%;" />]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xdebug </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl2 ip配置</title>
      <link href="2021/03/24/wsl2%20ip%E9%85%8D%E7%BD%AE/"/>
      <url>2021/03/24/wsl2%20ip%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="自动获取wsl2ip"><a href="#自动获取wsl2ip" class="headerlink" title="自动获取wsl2ip"></a>自动获取wsl2ip</h2><blockquote><p>每次重启获取内部ip 并且会写入到 windows 的 hosts 中</p></blockquote><p><a href="https://link.zhihu.com/?target=https://github.com/shayne/go-wsl2-host/">https://link.zhihu.com/?target=https%3A//github.com/shayne/go-wsl2-host/</a></p><p>安装脚本</p><pre><code>.\wsl2host.exe install</code></pre><p>输入电脑登录的帐号密码</p><pre><code class="shell">Windows Username: 用户名Windows Password: 密码</code></pre><p>启动</p><pre><code class="shell">.\wsl2host.exe start </code></pre><p>失败的话检查服务</p><p><code>win + R</code> 输入 <code>services</code> </p><img src="https://raw.githubusercontent.com/zxr615/md-images/master/images20210324215158.png" alt="image-20210324215157987" style="zoom:50%;" /><p>双击可编辑密码，我这里必须要在这里设置一下密码，命令行设置的密码无效</p><img src="https://raw.githubusercontent.com/zxr615/md-images/master/images20210324215358.png" alt="image-20210324215358692" style="zoom:50%;" /><h2 id="windows端口转发"><a href="#windows端口转发" class="headerlink" title="windows端口转发"></a>windows端口转发</h2><p>增减端口转发</p><blockquote><p>listenport 为 windows 需要监听的端口，connectport 是 WSL2 你的服务端口，如果不用转发了可以执行删除命令</p></blockquote><pre><code class="console">netsh interface portproxy add v4tov4 listenport=8080 connectaddress=ubuntu.wsl connectport=8080 listenaddress=* protocol=tcp</code></pre><p>删除端口转发</p><pre><code class="console">netsh interface portproxy delete v4tov4 listenport=8080 protocol=tcp</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> wsl2 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用phpbench做基准测试</title>
      <link href="2021/03/19/%E4%BD%BF%E7%94%A8phpbench%E5%81%9A%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
      <url>2021/03/19/%E4%BD%BF%E7%94%A8phpbench%E5%81%9A%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/phpbench/phpbench">https://github.com/phpbench/phpbench</a></p><h2 id="文档地址"><a href="#文档地址" class="headerlink" title="文档地址"></a>文档地址</h2><p><a href="https://phpbench.readthedocs.io/en/latest/quick-start.html">https://phpbench.readthedocs.io/en/latest/quick-start.html</a></p><h2 id="安装phpbench"><a href="#安装phpbench" class="headerlink" title="安装phpbench"></a>安装phpbench</h2><pre><code class="console">composer global require phpbench/phpbench --dev -vvv</code></pre><h2 id="创建phpbench-json-配置文件"><a href="#创建phpbench-json-配置文件" class="headerlink" title="创建phpbench.json 配置文件"></a>创建phpbench.json 配置文件</h2><p>在项目的根目录中创建一个文件：<code>phpbench.json</code></p><p><a href="https://phpbench.readthedocs.io/en/latest/quick-start.html#phpbench-configuration">PHPBench配置</a></p><pre><code class="json">&#123;    &quot;bootstrap&quot;: &quot;vendor/autoload.php&quot;&#125;</code></pre><h2 id="修改composer-json"><a href="#修改composer-json" class="headerlink" title="修改composer.json"></a>修改composer.json</h2><pre><code class="json">&quot;autoload-dev&quot;: &#123;    &quot;psr-4&quot;: &#123;        &quot;Acme\\Tests\\&quot;: &quot;tests/&quot;    &#125;&#125;,</code></pre><h2 id="更新-autoloader"><a href="#更新-autoloader" class="headerlink" title="更新 autoloader"></a>更新 autoloader</h2><pre><code class="console">composer du</code></pre><h2 id="编写Bench代码"><a href="#编写Bench代码" class="headerlink" title="编写Bench代码"></a>编写Bench代码</h2><p>方法必须以 <code>bench</code> 开头</p><pre><code class="php">class Test&#123;    public function benchTest()    &#123;        usleep(300);    &#125;&#125;</code></pre><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><pre><code>phpbench run tests/Benchmark/Test.php --report=default</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><pre><code class="console">➜  pay phpbench run tests/Benchmark/Test.php --report=defaultPhpBench @git_tag@. Running benchmarks.Using configuration file: /Users/tuju/Project/pay/phpbench.json\Tests\Benchmark\Test    benchConsume............................I0 [μ Mo]/r: 481.000 481.000 (μs) [μSD μRSD]/r: 0.000μs 0.00%1 subjects, 1 iterations, 1 revs, 0 rejects, 0 failures, 0 warnings(best [mean mode] worst) = 481.000 [481.000 481.000] 481.000 (μs)⅀T: 481.000μs μSD/r 0.000μs μRSD/r: 0.000%suite: 134628febd27af811e3ceaa765bccf4c891bc2f4, date: 2021-03-19, stime: 04:11:57+-----------+--------------+-----+------+------+------------+-----------+--------------+----------------+| benchmark | subject      | set | revs | iter | mem_peak   | time_rev  | comp_z_value | comp_deviation |+-----------+--------------+-----+------+------+------------+-----------+--------------+----------------+| Test      | benchConsume | 0   | 1    | 0    | 4,270,848b | 481.000μs | 0.00σ        | 0.00%          |+-----------+--------------+-----+------+------+------------+-----------+--------------+----------------+</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用 <code>composer</code> 命令需要将 <code>composer</code> 的 <code>bin</code> 目录给 <code>export</code> 出来</p><pre><code class="console">export PATH=&quot;$HOME/.composer/vendor/bin&quot;:$PATH</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Test </tag>
            
            <tag> Benchmark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装node</title>
      <link href="2021/03/18/ubuntu/"/>
      <url>2021/03/18/ubuntu/</url>
      
        <content type="html"><![CDATA[<p>ubuntu 安装node</p><p><a href="https://github.com/nodesource/distributions">https://github.com/nodesource/distributions</a></p><pre><code># Using Ubuntucurl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash -sudo apt-get install -y nodejs</code></pre><p>将子模块 也 <code>clone</code> 下来</p><pre><code class="console">git clone --recurse-submodules https://github.com/zxr615/zxr615.github.io.git</code></pre><p>clone 子模块 </p><pre><code class="console">git submodule update --init --recursive</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用策略模式和简单工厂模式重写支付模块</title>
      <link href="2021/03/18/%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E9%87%8D%E5%86%99%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97/"/>
      <url>2021/03/18/%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E9%87%8D%E5%86%99%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>最近接到一个涉及支付的需求，旧代码看的有点头大，所以捋了捋逻辑，看了下时间，还是足够的，所以就重写了一遍支付模块，抽空记录一下过程。</p><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><ul><li>全部支付走统一的二维码生成接口，导致需要通过 type 区分接收不同的字段，随着支付方式越来越多，参数判断越来越多，难以维护</li><li>代码解构混乱，一个 <code>$data</code> 变量贯通整个方法，导致最后不知道 <code>$data</code> 变量里面什么数据，开发、排错越来越复杂</li><li>异常处理，业务代码处处抛出 <code>\Exception</code> 和捕获 <code>\Exception</code> ，导致如果程序遇到了系统异常也不能及时的通知错误</li></ul><h2 id="改造前的一段伪代码"><a href="#改造前的一段伪代码" class="headerlink" title="改造前的一段伪代码"></a>改造前的一段伪代码</h2><ol><li>所有业务逻辑错误也抛出 <code>\Exception</code> 异常，捕获 <code>\Exception</code> 后返回 <code>下单失败</code> 导致如果程序遇到真正错误时，无法及时排查错误</li><li>单看 <code>checkVerifyType()</code> 方法名会认为只是检查支付 <code>type</code> 是否正确， 但却不是，这个方法把所有该干不该干的事都干完了</li><li>传参用 <code>0</code> ，<code>1</code> 也不能明确知道是代表什么东西</li><li><code>qrcode</code> 接口参数也很复杂，例：<code>type</code> = 1时，必须要 <code>code</code> 参数； <code>type</code> = 2 时，必须要 <code>price</code> 参数；<code>type</code> = 3 时  ….</li><li><code>$data</code> 里面各种数据，有：请求数据，订单临时数据，订单预览数据，根据购买商品的不同又放入不同的数据，结果 <code>$data</code> 就是个大杂烩，修改起来实在一言难尽</li></ol><pre><code class="php">// 所有购买入口获取二维码的入口public function qrcode(Request $request)&#123;    try &#123;          // ...        $key = $this-&gt;checkVerifyType(0, 1);          // ...        return $key;    &#125; catch (\Exception $e) &#123;        return &#39;下单失败&#39;;    &#125;&#125;</code></pre><p>*/Service/PayService.php</p><pre><code class="php">public function checkVerifyType($payType1 = 0, $payType2 = 0)&#123;    $data = request()-&gt;all();    if (!ctype_digit(strval($data[&#39;type&#39;]))) &#123;        throw new \Exception(&#39;type err&#39;);    &#125;        // ..... 还有一堆的参数验证    switch ($data[&#39;type&#39;]) &#123;        case &#39;vip&#39;:            // ... 验证            $data[&#39;vip_info&#39;] = Vip::where(&#39;code&#39;, $data[&#39;code&#39;])-&gt;first();            break;        case &#39;recharge&#39;:            // ... 验证            $data[&#39;money&#39;] = $data[&#39;money&#39;];            break;        // case...    &#125;    // 优惠券判断    if ($data[&#39;coupon_id&#39;]) &#123;        $money = Coupon::where(&#39;id&#39;, $data[&#39;coupon_id&#39;])-&gt;value(&quot;money&quot;);        $data[&#39;reduce&#39;] = $money;        // ....    &#125;    // 订单预览信息    $data[&#39;show_title&#39;] = &quot;购买一个会员&quot;;    $data[&#39;show_money&#39;] = 100;      $key = &quot;abcdefg&quot;;    Redis::set($key, $data);    return $key;&#125;</code></pre><h2 id="着手改造"><a href="#着手改造" class="headerlink" title="着手改造"></a>着手改造</h2><blockquote><ol><li>涉及支付的模块有：开通会员、充值、购买单个商品等</li><li>开发支付流程：<ol><li>生成二维码（生成临时订单 <code>redis</code>，返回 <code>redis</code> 零时订单 <code>key</code>）</li><li>手机端确认购买信息（展示购买商品信息）</li><li>手机端确认支付 （通过临时订单的 <code>key</code> ，创建一条订单数据到数据库）</li><li>根据临时订单的 <code>key</code> 创建订单</li><li>拉起支付</li><li>回调</li></ol></li><li>涉及到的设计模式<ol><li>策略模式</li><li>简单工厂模式</li></ol></li></ol></blockquote><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>原来的返回格式：</p><pre><code class="php">public function json($code, $msg, $data)&#123;    return [&#39;status&#39; =&gt; $code, &#39;message&#39; =&gt; $msg, &#39;data&#39; =&gt; $data];&#125;// 调用json(200, &quot;Ok&quot;, []);</code></pre><p>虽然没什么大问题，但调用起来不太方便，也不直观，每次还需要传入一些不必要的参数，这里增加一些常用的返回方法</p><p>在 <code>BaseContrller</code> 中增加几个返回数据的方法，方便调用</p><pre><code class="php">const SUCCESS_CODE = 200;const SUCCESS_FAIL = 100;protected function success($msg = &#39;ok&#39;, $data = [], $code = self::SUCCESS_CODE)&#123;    return [&#39;status&#39; =&gt; $code, &#39;message&#39; =&gt; $msg, &#39;data&#39; =&gt; $data];&#125;protected function data($data = [], $msg = &#39;ok&#39;, $code = self::SUCCESS_CODE)&#123;    return [&#39;status&#39; =&gt; $code, &#39;message&#39; =&gt; $msg, &#39;data&#39; =&gt; $data];&#125;protected function fail($msg = &#39;ok&#39;, $data = [], $code = self::SUCCESS_FAIL)&#123;    return [&#39;status&#39; =&gt; $code, &#39;message&#39; =&gt; $msg, &#39;data&#39; =&gt; $data];&#125;</code></pre><h3 id="按模块区分不同的下单链接"><a href="#按模块区分不同的下单链接" class="headerlink" title="按模块区分不同的下单链接"></a>按模块区分不同的下单链接</h3><blockquote><p>由原来的统一 <code>qrcode</code> 链接分出 3 个接口，每个接口只需要接收自己需要的参数就行，不需要原来的 <code>type</code> 来区分参数 </p></blockquote><ol><li>开通会员： <code>/buy/vip</code></li><li>充值：<code>/buy/recharge</code></li><li>购买商品：<code>/buy/goods</code></li></ol><h3 id="创建临时订单策略"><a href="#创建临时订单策略" class="headerlink" title="创建临时订单策略"></a>创建临时订单策略</h3><ol><li><p>创建一个订单的 <code>抽象策略</code>，定义算法的接口，所有策略必须实现临时订单的接口，</p><p> app/Http/Services/PayOrder/PayOrderStrategy.php</p><pre><code class="php">abstract class PayOrderStrategy&#123;    abstract function createTemporaryOrder($request);&#125;</code></pre></li><li><p>创建一个 <code>Context</code> 类</p><p> app/Http/Services/PayOrder/PayOrderStrategy.php</p><pre><code class="php">class PayOrderContext&#123;    private $strategy;    public function __construct(PayOrderStrategy $payOrderStrategy)    &#123;        return $this-&gt;strategy = $payOrderStrategy;    &#125;    public function createOrder(Request $request)    &#123;        return $this-&gt;strategy-&gt;createTemporaryOrder($request);    &#125;&#125;</code></pre></li><li><p>基础的策略框架已经搭建好，现在就需要具体的策略了</p><blockquote><p>开通 vip 策略</p></blockquote><p> <code>$request</code> 是<a href="#%E5%AE%9E%E7%8E%B0%E5%BC%80%E9%80%9Avip%E6%8E%A5%E5%8F%A3">开通 vip</a> 接口中传入的 <code>$request</code></p><p> app/Http/Services/PayOrder/Strategy/VipStrategy.php</p><pre><code class="php">// 开通 vipclass VipStrategy extends PayOrderStrategy&#123;      // 组装临时订单的数据，然后存入 redis      // 这里是 vip 策略，所以只专注 vip 需要的数据就好    function createTemporaryOrder(Request $request)    &#123;        $packageCode = $request[&#39;code&#39;];        $package     = app(PayOrderService::class)-&gt;getVipByCode($packageCode);        // 临时订单数据           $tmpOrder = [            &#39;package_cope&#39; =&gt; $package-&gt;toArray(),            &#39;type&#39;         =&gt; PayOrderService::TYPE_VIP,            &#39;uid&#39;          =&gt; 1,            &#39;ip&#39;           =&gt; $request-&gt;ip(),            // ....        ];              return app(PayOrderService::class)-&gt;saveTemporaryOrder($tmpOrder);    &#125;&#125;</code></pre></li><li><p>创建一个订单服务类，写一些创建订单的公共方法</p><p> app/Http/Services/PayOrderService.php</p><pre><code>use Ramsey\Uuid\Uuid;class PayOrderService&#123;    const TYPE_VIP      = 1; // 购买 vip    const TYPE_RECHARGE = 2; // 充值    const TYPE_GOODS    = 3; // 购买商品    // 通过 code 查询 vip 套餐信息    public function getVipByCode(string $code)    &#123;        // 这里应是从数据库获取数据返回        return collect([&#39;id&#39; =&gt; 1, &#39;code&#39; =&gt; &#39;vip1&#39;, &#39;price&#39; =&gt; 100, &#39;vip_day&#39; =&gt; 30]);    &#125;    // 保存临时订单    public function saveTemporaryOrder(array $tmpOrder)    &#123;        $key = Uuid::uuid4()-&gt;toString();        Cache::set($key, $tmpOrder, 3);        return $key;    &#125;&#125;</code></pre><p> 目前的目录解构</p><p> app/Http/Services/</p><pre><code class="php">├── PayOrder│   ├── PayOrderContext.php│   ├── PayOrderStrategy.php│   └── Strategy│       └── VipStrategy.php└── PayOrderService.php</code></pre></li></ol><h3 id="实现开通vip接口"><a href="#实现开通vip接口" class="headerlink" title="实现开通vip接口"></a>实现开通vip接口</h3><p>所有接口的数据都是通过 <code>laravel</code> <a href="https://learnku.com/docs/laravel/5.6/validation/1372#106bee">表单请求验证</a></p><p>路由：routes/web.php</p><pre><code class="php">Route::get(&#39;/buy/vip&#39;, &quot;PayController@vip&quot;)-&gt;name(&#39;vip&#39;);</code></pre><p>app/Http/Controllers/PayController.php        </p><pre><code class="php">public function vip(Request $request)&#123;    $strategy = new VipStrategy();    $tmpOrderKey = (new PayOrderContext($strategy))-&gt;createOrder($request);    return $this-&gt;data([&#39;key&#39; =&gt; $tmpOrderKey]);&#125;</code></pre><pre><code class="curl">curl http://127.0.0.1:8000/buy/vip?code=vip1 | json&#123;  &quot;status&quot;: 200,  &quot;message&quot;: &quot;ok&quot;,  &quot;data&quot;: &#123;    &quot;key&quot;: &quot;35349845-0e76-4973-b240-67e7b3cdda42&quot;  &#125;&#125;</code></pre><p>临时订单已生成，现在需要需要开发手机扫码后的预览接口</p><h3 id="预览订单"><a href="#预览订单" class="headerlink" title="预览订单"></a>预览订单</h3><p>正常来说预览订单是每个支付都需要有的功能，所以增加一个抽象方法</p><ol><li><p>在 <code>app/Http/Services/PayOrder/PayOrderStrategy.php</code> 新增一个 <code>preview</code> 的抽象方法 </p><pre><code class="php">abstract class PayOrderStrategy&#123;    // 创建临时订单    abstract function createTemporaryOrder(Request $request);         // 预览订单    protected function preview(array $tmpOrder)    &#123;        throw new UnsupportedOperationException(&quot;不支持的方法&quot;);    &#125;&#125;</code></pre><p> 你可能会好奇，这里预览订单为什么要抛出一个异常呢？因为有些第三方支付没有手机支付，只能 pc 端跳转，所以就不会涉及预览这一说</p><p> 如果定义成 <code>abstract</code> 下面继承的方法有必须实现，这个非必须的就直接定义成 <code>protected</code> 并抛出一个异常，开发的时候如果错误的调用了这个方法就会知道，当前支付方式不支持订单的预览</p></li><li><p>开通 vip 策略实现 <code>preview</code> 方法，参数是临时订单的信息</p><p> app/Http/Services/PayOrder/Strategy/VipStrategy.php</p><pre><code class="php">function createTemporaryOrder(Request $request)&#123; /*...*/ &#125;function preview(array $tmpOrder)&#123;    $preview = [        &#39;title&#39;   =&gt; &#39;开通会员&#39;,        &#39;price&#39;   =&gt; $tmpOrder[&#39;price&#39;],        &#39;vip_day&#39; =&gt; $tmpOrder[&#39;vip_day&#39;]    ];    return $preview;&#125;</code></pre></li><li><p>预览订单接口</p><p> 这个接口返回一个页面，手机扫码收可以预览并且有下单按钮</p><p> 路由：routes/web.php</p><pre><code class="php">Route::get(&#39;/buy/preview&#39;, &quot;PayController@preview&quot;)-&gt;name(&#39;preview&#39;);</code></pre><p> app/Http/Controllers/PayController.php</p><pre><code class="php">// 预览订单接口public function preview(Request $request)&#123;    // 请求下单接口后返回的临时订单 key    $tmpOrderKey = $request-&gt;get(&#39;key&#39;);    // 获取临时订单    $tmpOrder = app(PayOrderService::class)-&gt;getTemporaryOrder($tmpOrderKey);    if (!$tmpOrder) &#123;        throw new TemporaryOrderException(&quot;订单已过期&quot;);    &#125;    $strategy = new VipStrategy();    $preview = (new PayOrderContext($strategy))-&gt;preview($tmpOrder);    return view(&#39;preview&#39;, $preview);&#125;</code></pre></li><li><p>生成二维码</p><p> 前端请求 vip 接口之后使用返回的临时订单 key，作为 <code>query</code> 参数请求 <code>预览订单</code> 接口</p><p> <code>http://127.0.0.1:8000/buy/preview?key=35349845-0e76-4973-b240-67e7b3cdda42</code></p>  <div center="left">      <img src="https://cdn.jsdelivr.net/gh/zxr615/md-images/images/2020image-20210317142724525.png" alt="下单二维码" width=150 />      <img src="https://cdn.jsdelivr.net/gh/zxr615/md-images/images/2020image-20210317142241260.png" alt="手机确认支付页面" width=150 />  </div></li></ol><ol start="5"><li><p>接下来就是立即支付了，但立即支付前还有个问题，预览订单接口的 <code>策略选择</code> 似乎有点问题，这里设计的预览订单接口不论是 <code>开通 vip</code> 还是 <code>充值</code> 都是请求这个接口，所以这里还需要判断一下购买的类型来调用不同的策略。</p><p> 这里用临时订单中的 <code>type</code> 来判断支付的类型，根据 <code>type</code> 来选择策略</p><pre><code class="php">public function preview(Request $request)&#123;    ...        $strategy = new \stdClass();    switch ($tmpOrder[&#39;type&#39;]) &#123;        case PayOrderService::TYPE_VIP:            $strategy = new VipStrategy();            break;        case PayOrderService::TYPE_RECHARGE:            // $strategy = new RechargeStrategy();            break;        // ...    &#125;    $preview  = (new PayOrderContext($strategy))-&gt;preview($tmpOrder);    return view(&#39;preview&#39;, $preview);&#125;</code></pre><p> 好嘛~，问题又来了，这 <code>switch</code> 看着有点不爽，再把它独立出来吧，加一个获取策略的 <code>简单工厂</code> ，接下来优化这段选择策略的代码</p><p> 创建 <code>PreviewFactory</code> 简单工厂</p><p> <code>touch app/Http/Services/PayOrder/PreviewFactory.php</code></p><pre><code class="php">namespace App\Http\Services\PayOrder;use App\Exceptions\BusinessException;use App\Exceptions\TemporaryOrderException;use App\Http\Services\PayOrder\Strategy\VipStrategy;use App\Http\Services\PayOrderService;class PreviewFactory&#123;    public static function strategy(string $key)    &#123;        // 获取临时订单        $tmpOrder = app(PayOrderService::class)-&gt;getTemporaryOrder($key);        if (!$tmpOrder) &#123;            throw new TemporaryOrderException(&quot;订单已过期&quot;);        &#125;        $strategy = new \stdClass();        switch ($tmpOrder[&#39;type&#39;]) &#123;            case PayOrderService::TYPE_VIP:                $strategy = new VipStrategy();                break;            case PayOrderService::TYPE_RECHARGE:                // return new Recharge();                break;            // ...            default:                throw new BusinessException(&#39;订单类型错误.&#39;);        &#125;        return $strategy;    &#125;&#125;</code></pre><p> 现在再来看看 <code>preview</code> 接口</p><pre><code class="php">public function preview(Request $request)&#123;    $tmpOrderKey = $request-&gt;get(&#39;key&#39;);    try &#123;        $preview = PreviewFactory::strategy($tmpOrderKey)-&gt;preview($tmpOrderKey);    &#125; catch (TemporaryOrderException $e) &#123;        return $this-&gt;fail($e-&gt;getMessage());    &#125;    return view(&#39;preview&#39;, $preview);&#125;</code></pre></li></ol><h3 id="发起支付"><a href="#发起支付" class="headerlink" title="发起支付"></a>发起支付</h3><ol><li><p>和创建订单策略同样，我们也创建一个支付策略</p><p> /Users/tuju/Project/pay/app/Http/Services/Payment</p><pre><code class="tree">Payment├── PaymentContext.php├── PaymentFactory.php├── PaymentStrategy.php└── Strategy    ├── AlipayStrategy.php    ├── UnionStrategy.php    └── WechatStrategy.php</code></pre></li><li><p>定义支付接口</p><p> PaymentStrategy.php</p><pre><code>interface PaymentStrategy&#123;    public function pay(array $order);&#125; </code></pre></li><li><p>上下文联系</p><p> PaymentContext.php</p><pre><code class="php">class PaymentContext&#123;    private $strategy;    public function __construct(PaymentStrategy $paymentStrategy)    &#123;        return $this-&gt;strategy = $paymentStrategy;    &#125;    public function pay(array $order)    &#123;        return $this-&gt;strategy-&gt;pay($order);    &#125;&#125;</code></pre></li><li><p>获取支付策略的工厂</p><p> PaymentFactory.php</p><pre><code class="php">class PaymentFactory&#123;    public static function strategy(string $payType)    &#123;        switch ($payType) &#123;            case &#39;wechat&#39;:                $strategy = new WechatStrategy();                break;            case &#39;alipay&#39;:                $strategy = new AlipayStrategy();                break;            case &#39;union&#39;:                $strategy = new UnionStrategy();                break;            // case...            default:                throw new BusinessException(&quot;支付方式不存在&quot;);        &#125;        return $strategy;    &#125;&#125;</code></pre></li><li><p>制定具体支付策略</p><ol><li><p>支付宝策略<br> Strategy/AlipayStrategy.php</p><pre><code class="php">class AlipayStrategy implements PaymentStrategy&#123;    public function pay(array $order)    &#123;        /**        * 向支付宝请求        * @see 支付宝官方sdk https://github.com/alipay/alipay-easysdk/tree/master/php        * @see 第三方sdk https://github.com/lokielse/omnipay-alipay        */        return &quot;https://www.alipay.com/&quot;;    &#125;&#125;</code></pre></li><li><p>微信策略<br>Strategy/WechatStrategy.php</p></li></ol><pre><code class="php">class WechatStrategy implements PaymentStrategy&#123;    public function pay(array $order)    &#123;        /**        *        * @see 微信官方 https://github.com/wechatpay-apiv3/wechatpay-guzzle-middleware        * @see 官方文档 https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_6_2.shtml        * @see 第三方sdk https://github.com/lokielse/omnipay-wechatpay        */        return &quot;https://pay.weixin.qq.com/&quot;;    &#125;&#125;</code></pre></li><li><p>确认支付接口</p><p> app/Http/Controllers/PayController.php</p><pre><code class="php">public function pay(Request $request)&#123;    $tmpOrderKey = $request-&gt;get(&#39;key&#39;);    // pay_type=wechat|alipay|union    $payType = $request-&gt;get(&#39;pay_type&#39;);    // 处理订单数据、创建订单    $tmpOrder = app(PayOrderService::class)-&gt;getTemporaryOrder($tmpOrderKey);    $order = [ /** ... */];    $created = app(PayOrderService::class)-&gt;createOrder($order);    if (!$created) &#123;        return $this-&gt;fail(&quot;支付失败, 请重新生成订单.&quot;);    &#125;    // 发起支付    try &#123;        // 前面我们定义了一个支付策略工厂模式，帮助我们实例化策略，所以这里传入我们的支付方式        // 工厂就会帮我们对应支付策略返回回来，然后我们再统一调用 pay() 这个方法        $strategy = PaymentFactory::strategy($payType);        // 一般第三方会返回一个支付跳转链接，点击确认支付的时候用户是已经在手机页面了        // 所以直接跳转链接就可以拉起对应的支付了。        $url = (new PaymentContext($strategy))-&gt;pay($created);    &#125; catch (BusinessException $e) &#123;        $this-&gt;fail($e-&gt;getMessage());    &#125;    // 跳转    return redirect($url);&#125;</code></pre></li><li><p>最后列出下最终策略模块的树状图</p><pre><code>├── PayOrder 支付相关策略集合│   ├── PayOrderContext.php│   ├── PayOrderStrategy.php│   ├── PreviewFactory.php│   └── Strategy 具体策略，如果要充值，则新建一个充值策略即可，新增的方式也不会影响到开通会员的相关功能│       └── VipStrategy.php 开通 vip 策略├── PayOrderService.php 一些公用方法└── Payment 支付相关策略集合    ├── PaymentContext.php    ├── PaymentFactory.php    ├── PaymentStrategy.php    └── Strategy 具体策略，可以增加各种第三方支付        ├── AlipayStrategy.php 支付宝        ├── UnionStrategy.php 微信        └── WechatStrategy.php 银联</code></pre></li></ol><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul><li><p>将接口细分，不再是所有订单都进入同一个方法，解决了参数混乱问题</p></li><li><p>把大杂烩 <code>$data</code> 中的数据全部切分到每个不同的策略中去，而不是在方法中使用大量的 <code>if</code> 和 <code>switch</code> 来处理，再增加类型时只需要关注新增的策略即可</p></li><li><p>把接口数据用 <code>laravel</code> <a href="https://learnku.com/docs/laravel/5.6/validation/1372#106bee">表单请求验证</a> 来判断，而不是在 <code>controller</code> 和  <code>service</code> 层用 <code>if</code> 来判断</p></li><li><p>把 <code>\Exception</code> 代码全部替换成相应的业务异常</p><p>​    </p></li></ul><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>已更新：<a href="https://learnku.com/articles/56364">使用策略模式和简单工厂模式重写支付模块(二)-优化$request </a></p><ul><li><code>$request</code> 我认为还是不要往下传递比较好，最好在控制器中处理，但整体支付逻辑还是比较复杂，传参的话又需要传入很多参数，暂时也没有想出什么好的方法，所以还是决定将 <code>$request</code> 往下传递了。</li><li>创建订单中的零时订单存入到 redis 后再获取，还是不能明确知道数组里具体存入了什么数据，在 GO 中在序列化 <code>json</code> 时需要一个 <code>struct</code> 来支持，明确表名 json 中有什么字段，这样开发时既不容易出错，也减少很多梳理代码的时间；我认为可以新建一个 class 来模拟 GO 中的 <code>struct</code> 来明确 json 里面有什么数据。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/zxr615/rewrite-pay-module">https://github.com/zxr615/rewrite-pay-module</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>不要抛出 <code>\Exception</code> 异常，业务上的错误异常应该抛出自定义异常</p></li><li><p>尽量不要去捕获 <code>\Exception</code> 异常，<code>\Exception</code> 异常应该由顶层的 <code>Handel</code> 去处理；如遇到事务需要 <code>rollback</code> 的话，捕获 <code>Exception</code> 后，在返回错误信息前，需要手动记录下异常的详细信息。</p></li><li><p>一段代码如果有两处以上用到，应该独立出一个公共方法。</p></li><li><p>参数的验证在控制层面就校验完成，不要再传到 service 中处理。</p></li><li><p>善用设计模式</p></li><li><p>不要用 <code>0</code>, <code>1</code>, <code>2</code> 传参、判段等，不梳理上下文代码，实在是不知道什么意思，如果改变了其代号意思，则所有涉及到的地方都需要修改判断，可以用常量来管理各种代号。</p><pre><code class="php">public const PAY_STATUS_FAIL = 0;public const PAY_STATUS_OK   = 1;public const PAY_STATUS_WAIT = 2;public function give($payStatus)&#123;    // 最不明确的方法, 如果没注释真不知道什么意思    if ($payStatus == 1) &#123;        // ...    &#125;    // 比较好的方法，即便没有注释，意思也比较明确    if ($payStatus == self::PAY_STATUS_OK) &#123;        // ...    &#125;    // 我更喜欢用的方法，定义一个方法，看方法名知其意    if ($this-&gt;isPaid($payStatus)) &#123;        // ...    &#125;&#125;// 是否已支付完成public function isPaid($payStatus)&#123;    return $payStatus == self::PAY_STATUS_OK;&#125;</code></pre></li></ol><p>最后，大家有什么改进之处，或者疑问之处欢迎大家提出、指正。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
            <tag> Alipay </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh使用记录</title>
      <link href="2021/01/01/ssh%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>2021/01/01/ssh%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh-key"></a>生成 ssh-key</h2><pre><code class="console">ssh-keygen -t rsa -C &quot;12345@qq.com&quot;</code></pre><h2 id="免密远程-SSH-登录"><a href="#免密远程-SSH-登录" class="headerlink" title="免密远程 SSH 登录"></a>免密远程 SSH 登录</h2><ol><li><p>将本地 <code>id_rsa.pub</code> 添加到本地的 <code>authorized_keys</code> 中</p></li><li><p>将本地 <code>id_rsa.pub</code> 添加到服务端 <code>authorized_keys</code> 中</p></li><li><p>服务端配置允许公钥方式登录</p><pre><code class="shell">  vim /etc/ssh/sshd_config  # 公钥登录  PubkeyAuthentication yes  # 公钥文件  AuthorizedKeysFile .ssh/authorized_keys  # 密码登录  PasswordAuthentication yes</code></pre></li><li><p>重启 ssh</p><pre><code class="console">sudo service ssh restart</code></pre></li><li><p>配置</p><pre><code class="console">cat ~/.ssh/id_rsa.pub</code></pre><pre><code class="shell"># 客户端中的「id_rsa.pub」内容追加进服务端的 「authorized_keys」中sudo vim ~/.ssh/authorized_keys# 免密登录SSH fanwei@192.168.0.1</code></pre></li></ol><h2 id="区分多个服务器"><a href="#区分多个服务器" class="headerlink" title="区分多个服务器"></a>区分多个服务器</h2><p>客户端：</p><pre><code>vim ~/.ssh/configHost ubuntu    HostName fanwei.cn    Port 22    User fanwei    IdentityFile ~/.ssh/id_rsa    Host ubuntu2    HostName fanwei2.cn    Port 22    User fanwei    IdentityFile ~/.ssh/id_rsa</code></pre><p>免密登录：<code>SSH ubuntu</code></p><h2 id="PhpStorm-Terminal-中配置快捷登录-ssh"><a href="#PhpStorm-Terminal-中配置快捷登录-ssh" class="headerlink" title="PhpStorm Terminal 中配置快捷登录 ssh"></a>PhpStorm Terminal 中配置快捷登录 ssh</h2><p><code>Settings -&gt; Tools -&gt; Terminal</code></p><p><img src="https://cdn.jsdelivr.net/gh/zxr615/md-images/images/2020/image-20200830204459428.png"></p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.howtoing.com/how-to-set-up-ssh-keys-on-ubuntu-1804">https://www.howtoing.com/how-to-set-up-ssh-keys-on-ubuntu-1804</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>samba使用记录</title>
      <link href="2020/11/11/samba%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>2020/11/11/samba%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="http://cn.linux.vbird.org/linux_server/0370samba_2.php">鸟哥的私房菜-第十六章、文件服务器之二： SAMBA 服务器</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code># sambasudo apt install samba# samba-clientsudo apt install smbclient</code></pre><h2 id="免密配置"><a href="#免密配置" class="headerlink" title="免密配置"></a>免密配置</h2><pre><code class="shell">[global]   workgroup = WORKGROUP   server string = %h server (Samba, Ubuntu)   dns proxy = no   log file = /var/log/samba/log.%m   max log size = 1000   panic action = /usr/share/samba/panic-action %d   server role = standalone server   passdb backend = tdbsam   obey pam restrictions = yes   unix password sync = yes   passwd program = /usr/bin/passwd %u   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .   pam password change = yes   map to guest = bad user   usershare allow guests = yes   # 创建文件用户   force user = fanwei   # 创建文件组   force group = fanwei   create mask = 0777   directory mask = 0777[project]    comment = Project    path = /home/fanwei/project    writable = yes    browseable = yes    guest ok = yes</code></pre><p><code>sudo systemctl restart smbd.service</code></p><h2 id="测试语法"><a href="#测试语法" class="headerlink" title="测试语法"></a>测试语法</h2><p><code>testparm</code></p><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><h3 id="smbclient"><a href="#smbclient" class="headerlink" title="smbclient"></a>smbclient</h3><pre><code class="shell">smbclient -L //127.0.0.1</code></pre><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>在文件资源中输入<code>\\ip</code></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>如果访问不了、无法写入，检查文件夹权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Samba </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
